---
title: "scrape_partyinfos"
author: "Stefan Haußner"
date: "3 3 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(rvest)
```

# Infos from EuropeElects.eu (maybe we should ask them at some point)

# Functions

Unte werden noch die speziellen Funktionen für bspw. Bulgarien erstellt. Hier aber der Hauptteil und Hauptprinzip.

```{r}
f_inforaw <- function(html_partyblock){
  info_raw <- html_partyblock %>% 
    html_nodes("p") %>% 
    as.character() %>% 
    as_tibble_col(column_name = "text") %>% 
    separate(text, sep = "<br>", into = c("s1","s2","s3","s4","s5","s6","s7","s8")) %>% 
    filter(s2 != "") %>% 
    select(s1:s6)
  return(info_raw)
}
```

Zum Teil werden hier wegen mehrfacher "<strong>"-Klammerung im HTML-Code Parteien gedoppelt. Beim Namen wird deshalb nochmal extra alle verbleibenden strongs gelöscht und nur das erste Element ausgewählt.

```{r}
f_cleaninfo <- function(rawinfo){
  name <- rawinfo$s1 %>% read_html() %>% 
    html_nodes("strong") %>% 
    as.character() %>% 
    str_remove_all(pattern = "<[\\/]*strong>") %>% 
    .[1]
  
  abbr <- rawinfo$s1 %>% 
    str_remove_all(pattern = "<[\\/]*strong>") %>% 
    str_extract(pattern = "\\(.[^\\)]+\\)[:blank:]*$") %>% 
    str_remove(pattern = "[:blank:]$") %>%
    str_remove_all(pattern = "[\\(\\)]")

  name_en <- rawinfo$s2

  leader <- rawinfo$s3 %>% 
    str_remove(pattern = "<strong>Leader:</strong> ")

  orientation <- rawinfo$s4 %>% 
    str_remove(pattern = "<strong>Orientation:</strong> ")
  
  ep_affiliation <- rawinfo$s5 %>% 
    read_html() %>% 
    html_text() %>% 
    str_remove_all(pattern = "EP Affiliation: ") %>% 
    str_remove(pattern = " \\(.+\\)")

  eu_stance <- rawinfo$s6 %>% 
    read_html() %>% 
    html_text() %>% 
    str_remove("EU Stance:[:blank:]*") %>% 
    str_remove(" \\(Chapel Hill data\\) ")
  
  cleaninfo <- bind_cols(name = name, 
            abbr = abbr, 
            name_en = name_en, 
            leader = leader, 
            orientation = orientation, 
            ep_affiliation = ep_affiliation, 
            eu_stance = eu_stance)
  
  return(cleaninfo)
}
```

```{r}
f_countryparties <- function(url){
  html <- read_html(url)
  cntry <- html %>% html_nodes(".entry-title") %>% html_text()
  print(cntry)
  countryparties <- html %>% 
    html_nodes(".wp-block-media-text__content") %>% 
    map(f_inforaw) %>% 
    map_dfr(f_cleaninfo) %>% 
    mutate(cntry = cntry)
  return(countryparties)
}
```


# Apply


Theoretisch über die Seite direkt und read_html. Das wirft aber aus unerfindlichen Gründen bei manchen Ländern (auch immer wieder anderen) Fehler.

```{r}
country_urls <- read_html("https://europeelects.eu/") %>% 
  html_nodes(".custom-menu-class") %>% 
  html_nodes("li") %>%
  html_nodes("a") %>% 
  html_attr("href") %>% 
  .[c(5,11:17,19:21,23,24,26,28:30,34,37:39,43:46)]

read_html("https://europeelects.eu/hungary/")

country_urls %>% map(f_countryparties)
```

Daher lokal source-codes abgespeichert und hier geladen.

Probleme bei Belgien (klaro), Irland

Special Cases: Bulgaria, weil dort ein kyrillisches Schriftset genutzt wird. Die zweite Zeile ist dann nicht die englische Bezeichnung, sondern die "arabischer Schriftsatz" während die dritte Zeile erst die englische Übersetzung ist.

```{r}
partyinfos <- list.files(path = "../data/sourcecode_ee/", pattern = "source_") %>% 
  paste0("../data/sourcecode_ee/",.) %>% 
  .[-c(2,3,15)] %>% 
  map_dfr(f_countryparties)
partyinfos
```


# Special Cases

## Bulgaria

Der Parteiname ist hier auf au kyrillisch(?). In der jeweils zweiten Zeile folgt dann der Name in arabischem Alphabet. Für die Extrahierung des Parteikürzels wird aber dennoch die erste Zeile gebraucht, weshalb man das nicht oben über "select" in f_inforaw regeln kann.


```{r}
f_inforaw_bg <- function(html_partyblock){
  info_raw <- html_partyblock %>% 
    html_nodes("p") %>% 
    as.character() %>% 
    as_tibble_col(column_name = "text") %>% 
    separate(text, sep = "<br>", into = c("s1","s2","s3","s4","s5","s6","s7","s8")) %>% 
    filter(s2 != "") %>% 
    select(s1:s7)
  return(info_raw)
}
```

```{r}
f_cleaninfo_bg <- function(rawinfo){
  name <- rawinfo$s2 %>% read_html() %>% 
    html_nodes("em") %>% 
    as.character() %>% 
    str_remove_all(pattern = "<[\\/]*em>") %>% 
    .[1]
  
  abbr <- rawinfo$s1 %>% 
    str_remove_all(pattern = "<[\\/]*strong>") %>% 
    str_extract(pattern = "\\(.[^\\)]+\\)[:blank:]*$") %>% 
    str_remove(pattern = "[:blank:]$") %>%
    str_remove_all(pattern = "[\\(\\)]")

  name_en <- rawinfo$s3

  leader <- rawinfo$s4 %>% 
    str_remove(pattern = "<strong>Leader:</strong> ")

  orientation <- rawinfo$s5 %>% 
    str_remove(pattern = "<strong>Orientation:</strong> ")
  
  ep_affiliation <- rawinfo$s6 %>% 
    read_html() %>% 
    html_text() %>% 
    str_remove_all(pattern = "EP Affiliation: ") %>% 
    str_remove(pattern = " \\(.+\\)")

  eu_stance <- rawinfo$s7 %>% 
    read_html() %>% 
    html_text() %>% 
    str_remove("EU Stance:[:blank:]*") %>% 
    str_remove(" \\(Chapel Hill data\\) ")
  
  cleaninfo <- bind_cols(name = name, 
            abbr = abbr, 
            name_en = name_en, 
            leader = leader, 
            orientation = orientation, 
            ep_affiliation = ep_affiliation, 
            eu_stance = eu_stance)
  
  return(cleaninfo)
}
```

```{r}
path_bg <- list.files(path = "../data/sourcecode_ee/", pattern = "source_") %>% 
  paste0("../data/sourcecode_ee/",.) %>% 
  .[3]

html <- read_html(path_bg)
cntry <- html %>% html_nodes(".entry-title") %>% html_text()

partyinfos_bg <- html %>% 
  html_nodes(".wp-block-media-text__content") %>% 
  map(f_inforaw_bg) %>% 
  map_dfr(f_cleaninfo_bg) %>% 
  mutate(cntry = cntry)
```


## Belgium

Aufgrund teils sehr unterschiedlicher Anordnung der Infos, müssen hier z.T. sehr spezifische select-Anweisungen je nach Partei (Zeile) formuliert werden. Bspw. direkt bei der ersten Partei "Nieuw-Vlaamse Alliantie" gibt es ein Zusatzfeld mit "Language Group", welches die restlichen Felder verschiebt. Bei anderen Parteien wird auf die Infos aus den Partnerparteien der anderen Sprachgruppen verwiesen. 


Problem 1 gelöst: Problem 16 und 17 muss noch angegangen werden

```{r}
f_inforaw_be <- function(html_partyblock){
  info_raw_unselected <- html_partyblock %>% 
    html_nodes("p") %>% 
    as.character() %>% 
    as_tibble_col(column_name = "text") %>% 
    separate(text, sep = "<br>", into = c("s1","s2","s3","s4","s5","s6","s7","s8")) %>% 
    filter(s2 != "")
  return(info_raw_unselected)
}
```


```{r}
path_be <- list.files(path = "../data/sourcecode_ee/", pattern = "source_") %>% 
  paste0("../data/sourcecode_ee/",.) %>% 
  .[2]

html <- read_html(path_be)
cntry <- html %>% html_nodes(".entry-title") %>% html_text()

t <- html %>% 
  html_nodes(".wp-block-media-text__content") %>% 
  .[1:16] %>% 
  f_inforaw_be()


t1 <- t[1,] %>% select(s1, s2, s3=s4, s4=s5, s5=s6, s6=s7)
bind_rows(t1, t[2:dim(t)[1],])

%>% 
  .[17] %>% 
  html_nodes("p") %>% 
    as.character() %>% 
    as_tibble_col(column_name = "text") %>% 
    separate(text, sep = "<br>", into = c("s1","s2","s3","s4","s5","s6","s7","s8")) %>% 
    filter(s2 != "")

  if (t$s2 == "New Flemish Alliance") {
    t2 <- t %>% select(s1, s2, s4:s7)
  } else {
    t2 <- t %>% select(s1:s6)
  }
t
t2

```




